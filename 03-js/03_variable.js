console.log('JS 연결');

// Chap. 1)
/**
 * * 변수
 * - 변할 수 있는 수. 즉, 정해진 값이 아닌 수 variable
 * - 데이터 보관함, 그 크기는 모두 동일하다.
 * - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
 *
 * 변수 선언: 변수 정의
 * 변수 할당: = 연산자를 이용해 값을 넣음
 * 초기화: 변수에 처음 값을 할당하는 순간
 */

// * 3가지 변수 키워드
// ### var
// - 선언 단계와 초기화 할당 단계가 동시에 진행이 되며, 초기화에는 undefined 값이 들어간다.
// - 재선언, 중복 선언이 가능하며, 예기치 못한 값을 반환할 수 있음.
// - 선언 이전에 참조하면 언제나 undefined를 반환한다.

// ### let
// - let 키워드로는 변수 중복 선언이 불가능하지만, 재할당이 가능하다.

// ### const
// - 재선언이 불가능하고, 재할당이 불가능하다.
// - 초반에 선언을 할 때 반드시 **초기화**를 동시에 진행해야 한다.

/*
    ## 재선언, 중복선언, 재할당 요약

    | 키워드 | 재선언 | 중복선언 | 재할당 |
      var      o       o      o
      let      x       x      o
      const    x       x      x
    --------------------------------
*/

// Chap. 2)
// 변수 선언 키워드 #1 - var
var a; // 변수 선언
console.log(a); // 변수 값 출력 (undefined: 값을 할당하지 않았음)

a = 2; // 변수 할당
console.log(a); // 변수 값 출력 (2)

var a2 = 4; // 변수 선언 & 할당 = 초기화
console.log(a2); // 4

var a2 = 5; // 재선언 가능
console.log(a2); // 5

a2 = 30; // 재할당 가능
console.log(a2); // 30

////////////////////////////////////
// 변수 선언 키워드 #2 - let
let b; // 변수 선언
console.log(b); // undefined: 변수 선언만 하고 값을 할당하지 않았으므로 초기값 (undefined) 출력

b = 7; // 변수 할당
console.log(b); // 7

let b2 = 77; // 변수 선언 & 할당 = 초기화
console.log(b2); // 77

// let b2 = 78; // error: let 키워드 재선언 & 중복 선언 불가능

b2 = 78; // 재할당 가능
console.log(b2); // 78

////////////////////////////////////
// 변수 선언 키워드 #3 - const
// -> 변수 선언과 할당이 동시에!!! (반드시)
// -> 변하지 않는 값을 변수에 저장할 때 사용 (상수)
// const c; // error: const 키워드는 선언, 할당이 반드시 동시에

const c = 3;
console.log(c); // 3

// const c = 4; // 재선언 불가능

// c = 33; // error: const 변수는 재할당이 불가능!
////////////////////////////////////
// 재선언 & 중복선언 => 엇비슷 해보이지만, "스코프"의 개념을 고려하면 차이가 명확함

// ** 재선언?
// : "같은 스코프" 내에서 동일한 변수 이름을 다시 선언하는 경우

// Ex1) var
var y = 10;
var y = 20;
console.log(y); // 20 출력

// Ex2) let
let z = 40;
// let z = 60; // 재선언 불가
console.log(z); // 40 출력

// ** 중복선언?
// : "다른 스코프" 에서도 동일한 변수 이름을 다시 선언하는 경우

// Ex1) var
if (true) {
  var s = 10; // 함수 스코프
}
if (true) {
  var s = 50; // 함수 스코프 (var는 블록 스코프를 따르지 않고, 함수 스코프를 따름)
}
console.log(s); // 50 (블록 밖에서도 접근 가능) ==> 예상치 못한 결과를 초래할 가능성!

// Ex2) let
if (true) {
  let e = 10;
}
if (true) {
  let e = 50;
}
console.log(e); // ReferenceError: e is not defined 다른 블록 스코프에서 호출했기 때문에

// ** 스코프?
// : 스코프는 "범위" 라고 생각하면 된다.
// 1. 전역 스코프
// 2. 지역 스코프(= 함수 스코프)
// 3. 블록 스코프( {} 감싸진 내부)

// Chap. 4)
// ** 호이스팅
// JavaScript에서 변수 및 함수 선언이 코드의 최상단으로 이동된 것처럼 동작하는 현상
// = 실제 코드가 이동한 것은 아님!
// -> 변수와 함수의 선언이 실제 코드의 실행 전에 처리
// -> 이는 코드를 이해하고 예측하는 데 혼란을 줄 수 있음

// Ex)
console.log(x); // undefined
var x = 10;
console.log(x); // 10

// 실제 JS 엔진은 이렇게 해석함
// var x; // 변수 선언 (호이스팅)
// console.log(x); // undefined
// var x = 10;
// console.log(x); // 10

// = (말로 풀어보자면) 변수 x가 선언되기 전에 사용되었지만, JS 엔진은 선언을 최상단으로 올려서
// undefined를 출력한 후, 나중에 변수를 초기화 하여 값을 할당
// 변수 및, 함수는 사용하기 전에 반드시 선언하는 것이 좋습니다.

// ** let, const 키워드는 호이스팅을 줄이고, 블록스코프를 제공하여 변수의 유효 범위를 명확히 함
// ===> 최신 JavaScript 코드에서는 let과 const 사용하는 것이 매우 매우 권장됩니다.

////////////////////////////////////
// Chap. 5)
// 변수 이름 규칙 (= 식별자 규칙)
// 식별자: 이름을 붙일 때 사용하는 단어 (변수명, 함수명, 클래스명, ...)
// - 키워드 (예약어) 사용 불가능
//      - Q) 키워드란?
//      - A) 특별한 역할을 이미 하고 있는 단어
//      - ex) let, var, const, void, return, for, while, ...
// - 숫자 시작 x
// - 특수문자: _, $만 사용 가능
// - 공백 문자(space bar) x

// Q) 식별자에 단어 두개 이상 작성하고 싶은 경우?
// A) (관례)
// camelCase
// ex) redApple, isWater
// snake_case
// ex) red_apple, is_water

// Q) 상수란?
// A) 프로그램이 실행되는 동안 값이 변하지 않는 데이터를 나타낸다.
// 한번 정의되면 프로그램 실행 중에는 변경되지 않는 값을 말한다. (고정된 값)
// 보통 대문자로 표기함.(개발자 커뮤니케이션 사이에서 국룰)
// ex) TOMATO, APPLE
